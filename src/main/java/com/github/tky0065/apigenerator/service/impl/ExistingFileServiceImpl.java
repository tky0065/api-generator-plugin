package com.github.tky0065.apigenerator.service.impl;

import com.github.tky0065.apigenerator.service.ExistingFileService;
import com.github.tky0065.apigenerator.service.LoggingService;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VfsUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiDirectory;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;

/**
 * Implémentation du service de détection et gestion des fichiers existants.
 */
public class ExistingFileServiceImpl implements ExistingFileService {

    private final LoggingService loggingService;

    // Map pour stocker les choix de l'utilisateur (clé = packageName + className)
    private final Map<String, FileAction> userChoices = new ConcurrentHashMap<>();

    // Action globale à appliquer à tous les fichiers (si définie)
    private FileAction globalAction = null;

    // Signature ajoutée aux fichiers générés pour les identifier
    private static final String GENERATED_SIGNATURE = "// Generated by API Generator";

    // Motif pour détecter les fichiers Java
    private static final Pattern JAVA_FILE_PATTERN = Pattern.compile(".*\\.java$");

    public ExistingFileServiceImpl(LoggingService loggingService) {
        this.loggingService = loggingService;
    }

    @Override
    public FileAction checkFileExists(Project project, String packageName, String className, FileAction defaultAction) {
        // Si une action globale est définie, l'utiliser
        if (globalAction != null) {
            return globalAction;
        }

        // Vérifier si l'utilisateur a déjà fait un choix pour ce fichier
        String fileKey = getFileKey(packageName, className);
        if (userChoices.containsKey(fileKey)) {
            return userChoices.get(fileKey);
        }

        // Vérifier si le fichier existe
        PsiFile existingFile = findFile(project, packageName, className);
        if (existingFile == null) {
            // Le fichier n'existe pas, aucun conflit
            return FileAction.REPLACE;
        }

        // Vérifier si le fichier a été modifié manuellement
        boolean isModified = isFileManuallyModified(project, existingFile);

        // Si le fichier est modifié manuellement, demander à l'utilisateur (ASK)
        // Sinon, remplacer le fichier (REPLACE)
        return isModified ? FileAction.ASK : defaultAction;
    }

    @Override
    public void saveUserChoice(String packageName, String className, FileAction action, boolean applyToAll) {
        if (applyToAll) {
            // Appliquer à tous les fichiers
            globalAction = action;
            loggingService.info(null, "User choice for all files: " + action);
        } else {
            // Appliquer à un fichier spécifique
            String fileKey = getFileKey(packageName, className);
            userChoices.put(fileKey, action);
            loggingService.info(null, "User choice for " + fileKey + ": " + action);
        }
    }

    @Override
    public String generateAlternativeName(String originalName) {
        // Générer un nom avec un timestamp pour éviter les collisions
        long timestamp = System.currentTimeMillis();
        return originalName + "_" + timestamp;
    }

    @Override
    public boolean isFileManuallyModified(Project project, PsiFile file) {
        if (file == null) {
            return false;
        }

        try {
            // Lire le contenu du fichier
            String content = new String(file.getVirtualFile().contentsToByteArray(), StandardCharsets.UTF_8);

            // Vérifier si le fichier contient notre signature (indiquant qu'il a été généré par le plugin)
            // Si la signature est absente ou si le fichier a été modifié après génération, on considère qu'il a été modifié manuellement
            boolean hasSignature = content.contains(GENERATED_SIGNATURE);
            if (!hasSignature) {
                return true; // Pas notre signature, probablement créé manuellement
            }

            // Vérifier la date de dernière modification
            long lastModified = file.getVirtualFile().getTimeStamp();

            // Si le fichier a été modifié dans les dernières 24h, considérer qu'il a été modifié manuellement
            // (heuristique simple qui pourrait être améliorée)
            return System.currentTimeMillis() - lastModified < 24 * 60 * 60 * 1000;
        } catch (IOException e) {
            loggingService.error(project, "Error checking if file is manually modified: " + e.getMessage(), e);
            // En cas de doute, mieux vaut être prudent et considérer le fichier comme modifié manuellement
            return true;
        }
    }

    @Override
    public void resetUserChoices() {
        userChoices.clear();
        globalAction = null;
        loggingService.info(null, "User choices reset");
    }

    @Override
    public Map<String, FileAction> getUserChoices() {
        Map<String, FileAction> allChoices = new HashMap<>(userChoices);
        if (globalAction != null) {
            allChoices.put("GLOBAL", globalAction);
        }
        return allChoices;
    }

    /**
     * Crée une clé unique pour identifier un fichier.
     */
    private String getFileKey(String packageName, String className) {
        return packageName + "." + className;
    }

    /**
     * Trouve un fichier Java dans le projet.
     */
    private PsiFile findFile(Project project, String packageName, String className) {
        // Convertir le package en chemin de répertoire
        String packagePath = packageName.replace('.', '/');

        // Rechercher dans les répertoires sources du projet
        PsiManager psiManager = PsiManager.getInstance(project);
        VirtualFile baseDir = project.getBaseDir();

        if (baseDir == null) {
            return null;
        }

        // Chercher dans src/main/java
        VirtualFile srcDir = baseDir.findFileByRelativePath("src/main/java");
        if (srcDir != null) {
            VirtualFile packageDir = srcDir.findFileByRelativePath(packagePath);
            if (packageDir != null) {
                VirtualFile file = packageDir.findChild(className + ".java");
                if (file != null) {
                    return psiManager.findFile(file);
                }
            }
        }

        return null;
    }

    /**
     * Ajoute une signature à un fichier généré.
     *
     * @param content Le contenu du fichier
     * @return Le contenu avec la signature
     */
    public static String addGeneratedSignature(String content) {
        return GENERATED_SIGNATURE + "\n" + content;
    }
}
